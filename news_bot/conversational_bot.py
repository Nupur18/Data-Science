
from telegram.ext import Dispatcher
from flask import Flask, request
# enable logging (any kind of activity like some kind of error happened or a warning is raised, 
# we want that kind of information to be parsed in a systematic manner) 
# logging shows us any kind of logs which are generated while our bot is running
import logging

from telegram import Bot, Update, ReplyKeyboardMarkup
from telegram.ext.commandhandler import CommandHandler
from telegram.ext.filters import Filters
from telegram.ext.messagehandler import MessageHandler
from utils import get_reply, fetch_news, topics_keyboard

# format of log (time at which event happened, name of function/class due to which the event happened, 
# then levels - infprmation, warning or error, actual message generated by some Python program)
logging.basicConfig(format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s', level = logging.INFO)

# logger object which will be able to create any kind of logs for your program
logger = logging.getLogger(__name__)

# ----------------------------------------------------------------------------------------------------------
# by default any function which is passed inside CommandHandler takes two arguments - bot and update
# bot represents bot object and update represents the update object which we have received

# any reply that we are sending, we need to specify to which chat we are sending the reply, 
# so that's why we need to give chat_id to the bot

def start(bot, update):     # command is /start, / is understood, so not used above and here
    print(update)
    author = update.message.from_user.first_name    # name of the user who has sent the message 
    reply = "Hi! {}".format(author)
    bot.send_message(chat_id = update.message.chat_id, text = reply)

def _help(bot, update):
    help_txt = "Hey! This is a help text"
    bot.send_message(chat_id = update.message.chat_id, text = help_txt)

def news(bot, update):
    # send a message asking the user to choose a particular category/topic for the news
    bot.send_message(chat_id = update.message.chat_id, text = "Choose a category", 
    reply_markup = ReplyKeyboardMarkup(keyboard = topics_keyboard, one_time_keyboard = True))
    # keyboard is a list[list(strings)] which are the topics

def reply_text(bot, update):   # function will reply to the text messages
    intent, reply = get_reply(update.message.text, update.message.chat_id)
    if intent == "get_news":
        # in this case reply variable will be a dictionary which will contain all the parameters
        articles = fetch_news(reply)
        # passing each article's link one by one to telegram because at one go we can only pass 1 news article
        for article in articles:
            # passing link only because telgram will create a preview which already contains title and image related to the particular news
            bot.send_message(chat_id = update.message.chat_id, text = article['link'])  
    else:    
        bot.send_message(chat_id = update.message.chat_id, text = reply)

def echo_sticker(bot, update):
    bot.send_sticker(chat_id = update.message.chat_id, sticker = update.message.sticker.file_id)
    # file_id is the unique identifier of the sticker

def error(bot, update):
    # if error has happened, we can log that particular error
    logger.error("Update '%s' has caused error '%s'", update, update.error)

# ----------------------------------------------------------------------------------------------------------


TOKEN = "2104549596:AAHUOs_BfJVXQeDiF-2tOVzuVcy8YVqKNvg"

#  XXXXXXXXXXXXXXXX--------------------------------------------------------------------------------------------XXXXXXXXXXXXXXXX

# in order to create any Flask application, first of all create Flask app object
app = Flask(__name__)

# create some views / endpoints / routes on which we can receive some requests
@app.route('/')
def index():
    return "Hello!"

@app.route(f'/{TOKEN}', methods = ['GET', 'POST'])
def webhook():
    """webhook view which receives updates from telegram"""
    # create update object from json-format request data
    # request is an object which contains all the information of the cuurent request for this particular url
    update = Update.de_json(request.get_json(), bot)
    #process update
    dp.process_update(update)
    return "ok"
#  XXXXXXXXXXXXXXXX--------------------------------------------------------------------------------------------XXXXXXXXXXXXXXXX

# entry point for the program
if __name__ == '__main__':
    # creating telegram bot object
    bot = Bot(TOKEN)

    # set webhook for telegram bot by calling telegram API
    # tells telegram server that this is the callback url
    bot.set_webhook("https://2afb-2405-201-4003-d93e-399e-88b6-9be-43d1.ngrok.io/" + TOKEN)

    dp = Dispatcher(bot, None)  # queue object can be passed for keeping all the updates which are pending

    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("help", _help))
    dp.add_handler(CommandHandler("news", news))
    dp.add_handler(MessageHandler(Filters.text, reply_text))     # messagehandler is for only text messages
    dp.add_handler(MessageHandler(Filters.sticker, echo_sticker))   # messagehandler is for only text messages
    dp.add_error_handler(error)  # function for handling all types of errors

    app.run(port = 8443)