# POLLING PROGRAM

# from telegram.ext import Updater, dispatcher, Bot, Dispatcher
# from flask import Flask, request
# # 1. enable logging (any kind of activity like some kind of error happened or a warning is raised, 
# # we want that kind of information to be parsed in a systematic manner) 
# # logging shows us any kind of logs which are generated while our bot is running
# import logging

# from telegram.ext.commandhandler import CommandHandler
# from telegram.ext.filters import Filters
# from telegram.ext.messagehandler import MessageHandler
# from werkzeug.wrappers import request

# # format of log (time at which event happened, name of function/class due to which the event happened, 
# # then levels - infprmation, warning or error, actual message generated by some Python program)
# logging.basicConfig(format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s', level = logging.INFO)

# # logger object which will be able to create any kind of logs for your program
# logger = logging.getLogger(__name__)

# # ----------------------------------------------------------------------------------------------------------
# # by default any function which is passed inside CommandHandler takes two arguments - bot and update
# # bot represents bot object and update represents the update object which we have received

# # any reply that we are sending, we need to specify to which chat we are sending the reply, 
# # so that's why we need to give chat_id to the bot

# def start(bot, update):     # command is /start, / is understood, so not used above and here
#     print(update)
#     author = update.message.from_user.first_name    # name of the user who has sent the message 
#     reply = "Hi! {}".format(author)
#     bot.send_message(chat_id = update.message.chat_id, text = reply)

# def _help(bot, update):
#     help_txt = "Hey! This is a help text"
#     bot.send_message(chat_id = update.message.chat_id, text = help_txt)

# def echo_text(bot, update):
#     # sending back what the user has said
#     reply = update.message.text   # contains the text of the message that you have received from the user
#     bot.send_message(chat_id = update.message.chat_id, text = reply)

# def echo_sticker(bot, update):
#     bot.send_sticker(chat_id = update.message.chat_id, sticker = update.message.sticker.file_id)
#     # file_id is the unique identifier of the sticker

# def error(bot, update):
#     # if error has happened, we can log that particular error
#     logger.error("Update '%s' has caused error '%s'", update, update.error)

# # ----------------------------------------------------------------------------------------------------------


# # 2. create updater
# TOKEN = "2104549596:AAHUOs_BfJVXQeDiF-2tOVzuVcy8YVqKNvg"

# # polling program /updator keeps polling the telegram server, so whenever an update is given, that update will be handled by a dispatcher
# # updator is a class written in python-telegram-bot library, it will receive the updates from telegram 
# # and deliver them to a dispatcher which can handle those updates
# def main():
#     # updater is used when polling is needed
#     updater = Updater(TOKEN, use_context=False)

# # 3. create dispatcher
#     dp = updater.dispatcher


# # 4. add handlers (for a dispatcher, we need multiple handlers to handle different kind of situations or events)
# # CommandHandler is used to handle the commands
# # Filters is used to determine what kind of message you have received
#     dp.add_handler(CommandHandler("start", start))
#     dp.add_handler(CommandHandler("help", _help))
#     dp.add_handler(MessageHandler(Filters.text, echo_text))     # messagehandler is for only text messages
#     dp.add_handler(MessageHandler(Filters.sticker, echo_sticker))   # messagehandler is for only text messages
#     dp.add_error_handler(error)  # function for handling all types of errors


# # 5. start polling and wait for any signal to end the program 
#     updater.start_polling()  # trigger that we need to start the polling
#     logger.info("Started polling ...")
#     updater.idle()  # waits for us to press ctrl-C to stop polling


# # entry point for the program
# if __name__ == '__main__':
#     main()




from telegram.ext import Dispatcher
from flask import Flask, request
# enable logging (any kind of activity like some kind of error happened or a warning is raised, 
# we want that kind of information to be parsed in a systematic manner) 
# logging shows us any kind of logs which are generated while our bot is running
import logging

from telegram import Bot, Update
from telegram.ext.commandhandler import CommandHandler
from telegram.ext.filters import Filters
from telegram.ext.messagehandler import MessageHandler


# format of log (time at which event happened, name of function/class due to which the event happened, 
# then levels - infprmation, warning or error, actual message generated by some Python program)
logging.basicConfig(format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s', level = logging.INFO)

# logger object which will be able to create any kind of logs for your program
logger = logging.getLogger(__name__)

# ----------------------------------------------------------------------------------------------------------
# by default any function which is passed inside CommandHandler takes two arguments - bot and update
# bot represents bot object and update represents the update object which we have received

# any reply that we are sending, we need to specify to which chat we are sending the reply, 
# so that's why we need to give chat_id to the bot

def start(bot, update):     # command is /start, / is understood, so not used above and here
    print(update)
    author = update.message.from_user.first_name    # name of the user who has sent the message 
    reply = "Hi! {}".format(author)
    bot.send_message(chat_id = update.message.chat_id, text = reply)

def _help(bot, update):
    help_txt = "Hey! This is a help text"
    bot.send_message(chat_id = update.message.chat_id, text = help_txt)

def echo_text(bot, update):
    # sending back what the user has said
    reply = update.message.text   # contains the text of the message that you have received from the user
    bot.send_message(chat_id = update.message.chat_id, text = reply)

def echo_sticker(bot, update):
    bot.send_sticker(chat_id = update.message.chat_id, sticker = update.message.sticker.file_id)
    # file_id is the unique identifier of the sticker

def error(bot, update):
    # if error has happened, we can log that particular error
    logger.error("Update '%s' has caused error '%s'", update, update.error)

# ----------------------------------------------------------------------------------------------------------


TOKEN = "2104549596:AAHUOs_BfJVXQeDiF-2tOVzuVcy8YVqKNvg"

#  XXXXXXXXXXXXXXXX--------------------------------------------------------------------------------------------XXXXXXXXXXXXXXXX

# in order to create any Flask application, first of all create Flask app object
app = Flask(__name__)

# create some views / endpoints / routes on which we can receive some requests
@app.route('/')
def index():
    return "Hello!"

@app.route(f'/{TOKEN}', methods = ['GET', 'POST'])
def webhook():
    """webhook view which receives updates from telegram"""
    # create update object from json-format request data
    # request is an object which contains all the information of the cuurent request for this particular url
    update = Update.de_json(request.get_json(), bot)
    #process update
    dp.process_update(update)
    return "ok"
#  XXXXXXXXXXXXXXXX--------------------------------------------------------------------------------------------XXXXXXXXXXXXXXXX

# entry point for the program
if __name__ == '__main__':
    # creating telegram bot object
    bot = Bot(TOKEN)

    # set webhook for telegram bot by calling telegram API
    # tells telegram server that this is the callback url
    bot.set_webhook("https://2afb-2405-201-4003-d93e-399e-88b6-9be-43d1.ngrok.io/" + TOKEN)

    dp = Dispatcher(bot, None)  # queue object can be passed for keeping all the updates which are pending

    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("help", _help))
    dp.add_handler(MessageHandler(Filters.text, echo_text))     # messagehandler is for only text messages
    dp.add_handler(MessageHandler(Filters.sticker, echo_sticker))   # messagehandler is for only text messages
    dp.add_error_handler(error)  # function for handling all types of errors

    app.run(port = 8443)